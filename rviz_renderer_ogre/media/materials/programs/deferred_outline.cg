#include "sobel.cg"

float4 fp_main(
        float2 in_color_uv: TEXCOORD0, 
        float3 in_proj: TEXCOORD1,

        uniform sampler tex0: register(s0),
        uniform sampler tex1: register(s1),
        uniform float4 in_viewport_size,
        uniform float in_far_clip_dist) : COLOR 
{
  float dx = in_viewport_size.z;
  float dy = in_viewport_size.w;
  
  float4 mm = tex2D(tex1, in_color_uv + float2(0, 0)); // center tap
  float4 taps[9] =
  {
    tex2D(tex1, in_color_uv + float2(-dx, -dy)),
    tex2D(tex1, in_color_uv + float2(0, -dy)),
    tex2D(tex1, in_color_uv + float2(dx, -dy)),
    tex2D(tex1, in_color_uv + float2(-dx, 0)),
    mm,
    tex2D(tex1, in_color_uv + float2(dx, -0)),
    tex2D(tex1, in_color_uv + float2(-dx, dy)),
    tex2D(tex1, in_color_uv + float2(0, dy)),
    tex2D(tex1, in_color_uv + float2(dx, dy))
  };
  
  // Check normals
  float dots[9];
  for (int i = 0; i < 9; ++i)
  {
    dots[i] = dot(mm.xyz, taps[i].xyz);
  }
  
  float d1 = ceil(sobel(dots[0], dots[1], dots[2], dots[3], dots[4], dots[5], dots[6], dots[7], dots[8], 1.0) - 0.85);
  
  // Check depth
  float d2 = ceil(sobel(taps[0].a, taps[1].a, taps[2].a, taps[3].a, taps[4].a, taps[5].a, taps[6].a, taps[7].a, taps[8].a, in_far_clip_dist) - 0.9);
  
  // Add the two together
  float d = saturate(d1 + d2);
  discard(d < 1);
 
  //float4 col = tex2D(tex0, in_color_uv);
  //discard(col.a < 1);
  //col.rgb = sign(0.7 - length(float3(col.rgb))) * float3(0.7, 0.7, 0.7) + col.rgb;
  float3 col = float3(0.2, 0.2, 0.2);
  
  return float4(col.rgb, d);
  //return float4(mm.xyz, 1.0);
}


